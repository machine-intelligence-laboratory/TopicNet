<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>topicnet.viewers.topic_mapping API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>topicnet.viewers.topic_mapping</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import numpy as np
from scipy import optimize
from scipy.spatial import distance

from .top_tokens_viewer import TopTokensViewer
from .base_viewer import BaseViewer


def compute_topic_mapping(matrix_left, matrix_right, metric=&#39;euclidean&#39;):
    &#34;&#34;&#34;
    This function provides mapping of topics
    from one model to the topics of the other model
    based on their simmularity defined by the metrics.

    Parameters
    ----------
    matrix_left : np.array
        a matrix of N1 topics x M tokens from the first model
        each row is a cluster in M-dimensional feature space
    matrix_right : np.array
        a matrix of N2 topics x M tokens from the second model
        each row is a cluster in M-dimensional feature space
    metric : str or class
        a string defining metric to use, or function that computes
        pairwise distance between 2 matrices (Default value = &#39;euclidean&#39;)

    Returns
    -------
    tuple of ndarrays
        returns two ndarrays of indices, where each index
        corresponds to a topic from respective models

    &#34;&#34;&#34;
    if isinstance(metric, str):
        costs = distance.cdist(matrix_left, matrix_right, metric=metric)
    else:
        costs = metric(matrix_left, matrix_right)

    results = optimize.linear_sum_assignment(costs)
    return results


class TopicMapViewer(BaseViewer):
    def __init__(
        self,
        model,
        second_model,
        mode=&#39;min&#39;,
        metric=&#39;euclidean&#39;,
        class_ids=None,
    ):
        &#34;&#34;&#34;
        Performs a mapping between topics of two model
        matching two closest topics together based on
        the Hungarian algorithm.

        Parameters
        ----------
        model : TopicModel
            first model to compare
        second_model : TopicModel
            second model to compare
        mode : string
            &#34;min&#34; or &#34;max&#34;  
            &#34;min&#34; performs one to one mapping of 
            min(n_topics_first_model, n_topics_second_model) length  
            &#34;max&#34; performs mapping for
            max(n_topics_first_model, n_topics_second_model), in that case
            topics from model with minimal number will have a few topics mapped on it
        metric : str or function
            name of scipy metrics used in distance computation
            or function that computes pairwise distance between 2 matrices
            (Default value = &#34;euclidean&#34;)

        &#34;&#34;&#34;  # noqa: W291
        super().__init__(model=second_model)
        self.second_model = self.model
        super().__init__(model=model)
        # TODO the default library method for get_phi
        # returns  N x T matrix while we implemented T x N
        self.metric = metric
        self.mode = mode
        self.class_ids = class_ids

    def view(self, class_ids=None):
        &#34;&#34;&#34;
        Returns pairs of close topics.

        Parameters
        ----------
        class_ids : list of str, default - None
            parameter for model.get_phi method

        Returns
        -------
        tuple of nd.arrays of strings:
            two ordered arrays of topic name pairs

        &#34;&#34;&#34;
        if class_ids is None:
            class_ids = self.class_ids
        model_phi = self.model.get_phi(class_ids=class_ids).T
        second_model_phi = self.second_model.get_phi(class_ids=class_ids).T
        num_topics_first = model_phi.values.shape[0]
        num_topics_second = second_model_phi.values.shape[0]
        if self.mode == &#39;min&#39;:
            first_map_order, second_map_order = compute_topic_mapping(model_phi.values,
                                                                      second_model_phi.values,
                                                                      metric=self.metric)
            first_model_order = list(
                model_phi
                .iloc[first_map_order]
                .index.values
            )
            second_model_order = list(
                second_model_phi
                .iloc[second_map_order]
                .index.values
            )
            return first_model_order, second_model_order

        elif self.mode == &#39;max&#39;:
            more_topics_second = num_topics_first &lt;= num_topics_second

            if more_topics_second:
                iterate_phi_first = model_phi.values
                iterate_phi_second = second_model_phi.values
                phi_first_indexes = model_phi.index
                phi_second_indexes = second_model_phi.index
            else:
                iterate_phi_first = second_model_phi.values
                iterate_phi_second = model_phi.values
                phi_first_indexes = second_model_phi.index
                phi_second_indexes = model_phi.index

            first_map_order = []
            second_map_order = []
            while iterate_phi_second.shape[0] &gt; 0:
                answer_batch = compute_topic_mapping(iterate_phi_first,
                                                     iterate_phi_second,
                                                     metric=self.metric)
                first_map_order += list(phi_first_indexes[answer_batch[0]])
                second_map_order += list(phi_second_indexes[answer_batch[1]])
                iterate_phi_second = np.delete(iterate_phi_second, answer_batch[1], axis=0)
                phi_second_indexes = np.delete(phi_second_indexes, answer_batch[1], axis=0)

            if more_topics_second:
                first_model_order = list(
                    model_phi
                    .loc[first_map_order]
                    .index.values
                )
                second_model_order = list(
                    second_model_phi
                    .loc[second_map_order]
                    .index.values
                )
                return first_model_order, second_model_order

            second_model_order = list(
                second_model_phi
                .loc[first_map_order]
                .index.values
            )
            first_model_order = list(
                model_phi
                .loc[second_map_order]
                .index.values
            )
            return first_model_order, second_model_order
        else:
            raise TypeError(&#39;unknown self.mode value&#39;)

    def view_from_jupyter(
            self,
            display_output: bool = True,
            give_html: bool = False,
            **kwargs
    ):
        &#34;&#34;&#34;
        TopicMapViewer method recommended for use
        from jupyter notebooks
        returns closest pairs of models topics
        and visualizes their top tokens

        The class provide information about top tokens
        of the model topics providing with different methods to score that.

        Parameters
        ----------
        display_output
            if provide output at the end of method run
        give_html
            return html string generated by the method

        Returns
        -------
        out_html
            html string of the output

        Another Parameters
        ------------------
        **kwargs
            *kwargs* are optional `~.TopTokenViewer` properties
        &#34;&#34;&#34;
        from IPython.display import display_html
        from topicnet.cooking_machine.pretty_output import make_notebook_pretty
        if &#39;digits&#39; in kwargs:
            digits = kwargs.pop(&#39;digits&#39;)
        else:
            digits = 5

        make_notebook_pretty()
        first_model_order, second_model_order = self.view()
        token_view = (TopTokensViewer(model=self.model, **kwargs)
                      .view_from_jupyter(
                          topic_names=first_model_order,
                          digits=digits,
                          display_output=False,
                          give_html=True))
        second_token_view = (TopTokensViewer(model=self.second_model, **kwargs)
                             .view_from_jupyter(
                                 topic_names=second_model_order,
                                 digits=digits,
                                 display_output=False,
                                 give_html=True))
        model_name = self.model.model_id
        second_model_name = self.second_model.model_id
        out_html = &#39;&lt;table style=display:inline; cellpadding=&#34;5&#34;;&gt;&lt;tbody&gt;{0}&lt;/tbody&gt;&lt;/table&gt;&#39;
        first_element = (f&#39;&lt;tr&gt;&lt;td&gt; First model name: &#39;
                         f&#39;{model_name}&lt;/td&gt;&lt;td&gt; Second model &#39;
                         f&#39;name: {second_model_name}&lt;/td&gt;&lt;/tr&gt;{{0}}&#39;
                         )
        out_html = out_html.format(first_element)
        table_contents = []
        for t1, t2 in zip(token_view, second_token_view):
            table_contents += [f&#39;&lt;tr&gt;&lt;td&gt;{t1}&lt;/td&gt;&lt;td&gt;{t2}&lt;/td&gt;&lt;/tr&gt;&#39;]
        out_html = out_html.format(&#39;&#39;.join(table_contents))
        if display_output:
            display_html(out_html, raw=True)
        if give_html:
            return out_html</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="topicnet.viewers.topic_mapping.compute_topic_mapping"><code class="name flex">
<span>def <span class="ident">compute_topic_mapping</span></span>(<span>matrix_left, matrix_right, metric='euclidean')</span>
</code></dt>
<dd>
<section class="desc"><p>This function provides mapping of topics
from one model to the topics of the other model
based on their simmularity defined by the metrics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix_left</code></strong> :&ensp;<code>np.array</code></dt>
<dd>a matrix of N1 topics x M tokens from the first model
each row is a cluster in M-dimensional feature space</dd>
<dt><strong><code>matrix_right</code></strong> :&ensp;<code>np.array</code></dt>
<dd>a matrix of N2 topics x M tokens from the second model
each row is a cluster in M-dimensional feature space</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code> or <code>class</code></dt>
<dd>a string defining metric to use, or function that computes
pairwise distance between 2 matrices (Default value = 'euclidean')</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>ndarrays</code></dt>
<dd>returns two ndarrays of indices, where each index
corresponds to a topic from respective models</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compute_topic_mapping(matrix_left, matrix_right, metric=&#39;euclidean&#39;):
    &#34;&#34;&#34;
    This function provides mapping of topics
    from one model to the topics of the other model
    based on their simmularity defined by the metrics.

    Parameters
    ----------
    matrix_left : np.array
        a matrix of N1 topics x M tokens from the first model
        each row is a cluster in M-dimensional feature space
    matrix_right : np.array
        a matrix of N2 topics x M tokens from the second model
        each row is a cluster in M-dimensional feature space
    metric : str or class
        a string defining metric to use, or function that computes
        pairwise distance between 2 matrices (Default value = &#39;euclidean&#39;)

    Returns
    -------
    tuple of ndarrays
        returns two ndarrays of indices, where each index
        corresponds to a topic from respective models

    &#34;&#34;&#34;
    if isinstance(metric, str):
        costs = distance.cdist(matrix_left, matrix_right, metric=metric)
    else:
        costs = metric(matrix_left, matrix_right)

    results = optimize.linear_sum_assignment(costs)
    return results</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="topicnet.viewers.topic_mapping.TopicMapViewer"><code class="flex name class">
<span>class <span class="ident">TopicMapViewer</span></span>
<span>(</span><span>model, second_model, mode='min', metric='euclidean', class_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs a mapping between topics of two model
matching two closest topics together based on
the Hungarian algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>first model to compare</dd>
<dt><strong><code>second_model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>second model to compare</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code></dt>
<dd>"min" or "max"<br>
"min" performs one to one mapping of
min(n_topics_first_model, n_topics_second_model) length<br>
"max" performs mapping for
max(n_topics_first_model, n_topics_second_model), in that case
topics from model with minimal number will have a few topics mapped on it</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code> or <code>function</code></dt>
<dd>name of scipy metrics used in distance computation
or function that computes pairwise distance between 2 matrices
(Default value = "euclidean")</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TopicMapViewer(BaseViewer):
    def __init__(
        self,
        model,
        second_model,
        mode=&#39;min&#39;,
        metric=&#39;euclidean&#39;,
        class_ids=None,
    ):
        &#34;&#34;&#34;
        Performs a mapping between topics of two model
        matching two closest topics together based on
        the Hungarian algorithm.

        Parameters
        ----------
        model : TopicModel
            first model to compare
        second_model : TopicModel
            second model to compare
        mode : string
            &#34;min&#34; or &#34;max&#34;  
            &#34;min&#34; performs one to one mapping of 
            min(n_topics_first_model, n_topics_second_model) length  
            &#34;max&#34; performs mapping for
            max(n_topics_first_model, n_topics_second_model), in that case
            topics from model with minimal number will have a few topics mapped on it
        metric : str or function
            name of scipy metrics used in distance computation
            or function that computes pairwise distance between 2 matrices
            (Default value = &#34;euclidean&#34;)

        &#34;&#34;&#34;  # noqa: W291
        super().__init__(model=second_model)
        self.second_model = self.model
        super().__init__(model=model)
        # TODO the default library method for get_phi
        # returns  N x T matrix while we implemented T x N
        self.metric = metric
        self.mode = mode
        self.class_ids = class_ids

    def view(self, class_ids=None):
        &#34;&#34;&#34;
        Returns pairs of close topics.

        Parameters
        ----------
        class_ids : list of str, default - None
            parameter for model.get_phi method

        Returns
        -------
        tuple of nd.arrays of strings:
            two ordered arrays of topic name pairs

        &#34;&#34;&#34;
        if class_ids is None:
            class_ids = self.class_ids
        model_phi = self.model.get_phi(class_ids=class_ids).T
        second_model_phi = self.second_model.get_phi(class_ids=class_ids).T
        num_topics_first = model_phi.values.shape[0]
        num_topics_second = second_model_phi.values.shape[0]
        if self.mode == &#39;min&#39;:
            first_map_order, second_map_order = compute_topic_mapping(model_phi.values,
                                                                      second_model_phi.values,
                                                                      metric=self.metric)
            first_model_order = list(
                model_phi
                .iloc[first_map_order]
                .index.values
            )
            second_model_order = list(
                second_model_phi
                .iloc[second_map_order]
                .index.values
            )
            return first_model_order, second_model_order

        elif self.mode == &#39;max&#39;:
            more_topics_second = num_topics_first &lt;= num_topics_second

            if more_topics_second:
                iterate_phi_first = model_phi.values
                iterate_phi_second = second_model_phi.values
                phi_first_indexes = model_phi.index
                phi_second_indexes = second_model_phi.index
            else:
                iterate_phi_first = second_model_phi.values
                iterate_phi_second = model_phi.values
                phi_first_indexes = second_model_phi.index
                phi_second_indexes = model_phi.index

            first_map_order = []
            second_map_order = []
            while iterate_phi_second.shape[0] &gt; 0:
                answer_batch = compute_topic_mapping(iterate_phi_first,
                                                     iterate_phi_second,
                                                     metric=self.metric)
                first_map_order += list(phi_first_indexes[answer_batch[0]])
                second_map_order += list(phi_second_indexes[answer_batch[1]])
                iterate_phi_second = np.delete(iterate_phi_second, answer_batch[1], axis=0)
                phi_second_indexes = np.delete(phi_second_indexes, answer_batch[1], axis=0)

            if more_topics_second:
                first_model_order = list(
                    model_phi
                    .loc[first_map_order]
                    .index.values
                )
                second_model_order = list(
                    second_model_phi
                    .loc[second_map_order]
                    .index.values
                )
                return first_model_order, second_model_order

            second_model_order = list(
                second_model_phi
                .loc[first_map_order]
                .index.values
            )
            first_model_order = list(
                model_phi
                .loc[second_map_order]
                .index.values
            )
            return first_model_order, second_model_order
        else:
            raise TypeError(&#39;unknown self.mode value&#39;)

    def view_from_jupyter(
            self,
            display_output: bool = True,
            give_html: bool = False,
            **kwargs
    ):
        &#34;&#34;&#34;
        TopicMapViewer method recommended for use
        from jupyter notebooks
        returns closest pairs of models topics
        and visualizes their top tokens

        The class provide information about top tokens
        of the model topics providing with different methods to score that.

        Parameters
        ----------
        display_output
            if provide output at the end of method run
        give_html
            return html string generated by the method

        Returns
        -------
        out_html
            html string of the output

        Another Parameters
        ------------------
        **kwargs
            *kwargs* are optional `~.TopTokenViewer` properties
        &#34;&#34;&#34;
        from IPython.display import display_html
        from topicnet.cooking_machine.pretty_output import make_notebook_pretty
        if &#39;digits&#39; in kwargs:
            digits = kwargs.pop(&#39;digits&#39;)
        else:
            digits = 5

        make_notebook_pretty()
        first_model_order, second_model_order = self.view()
        token_view = (TopTokensViewer(model=self.model, **kwargs)
                      .view_from_jupyter(
                          topic_names=first_model_order,
                          digits=digits,
                          display_output=False,
                          give_html=True))
        second_token_view = (TopTokensViewer(model=self.second_model, **kwargs)
                             .view_from_jupyter(
                                 topic_names=second_model_order,
                                 digits=digits,
                                 display_output=False,
                                 give_html=True))
        model_name = self.model.model_id
        second_model_name = self.second_model.model_id
        out_html = &#39;&lt;table style=display:inline; cellpadding=&#34;5&#34;;&gt;&lt;tbody&gt;{0}&lt;/tbody&gt;&lt;/table&gt;&#39;
        first_element = (f&#39;&lt;tr&gt;&lt;td&gt; First model name: &#39;
                         f&#39;{model_name}&lt;/td&gt;&lt;td&gt; Second model &#39;
                         f&#39;name: {second_model_name}&lt;/td&gt;&lt;/tr&gt;{{0}}&#39;
                         )
        out_html = out_html.format(first_element)
        table_contents = []
        for t1, t2 in zip(token_view, second_token_view):
            table_contents += [f&#39;&lt;tr&gt;&lt;td&gt;{t1}&lt;/td&gt;&lt;td&gt;{t2}&lt;/td&gt;&lt;/tr&gt;&#39;]
        out_html = out_html.format(&#39;&#39;.join(table_contents))
        if display_output:
            display_html(out_html, raw=True)
        if give_html:
            return out_html</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="topicnet.viewers.base_viewer.BaseViewer" href="base_viewer.html#topicnet.viewers.base_viewer.BaseViewer">BaseViewer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="topicnet.viewers.topic_mapping.TopicMapViewer.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, class_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns pairs of close topics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>class_ids</code></strong> :&ensp;<code>list</code> of <code>str</code>, default - <code>None</code></dt>
<dd>parameter for model.get_phi method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>nd.arrays</code> of <code>strings</code>:</dt>
<dd>two ordered arrays of topic name pairs</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def view(self, class_ids=None):
    &#34;&#34;&#34;
    Returns pairs of close topics.

    Parameters
    ----------
    class_ids : list of str, default - None
        parameter for model.get_phi method

    Returns
    -------
    tuple of nd.arrays of strings:
        two ordered arrays of topic name pairs

    &#34;&#34;&#34;
    if class_ids is None:
        class_ids = self.class_ids
    model_phi = self.model.get_phi(class_ids=class_ids).T
    second_model_phi = self.second_model.get_phi(class_ids=class_ids).T
    num_topics_first = model_phi.values.shape[0]
    num_topics_second = second_model_phi.values.shape[0]
    if self.mode == &#39;min&#39;:
        first_map_order, second_map_order = compute_topic_mapping(model_phi.values,
                                                                  second_model_phi.values,
                                                                  metric=self.metric)
        first_model_order = list(
            model_phi
            .iloc[first_map_order]
            .index.values
        )
        second_model_order = list(
            second_model_phi
            .iloc[second_map_order]
            .index.values
        )
        return first_model_order, second_model_order

    elif self.mode == &#39;max&#39;:
        more_topics_second = num_topics_first &lt;= num_topics_second

        if more_topics_second:
            iterate_phi_first = model_phi.values
            iterate_phi_second = second_model_phi.values
            phi_first_indexes = model_phi.index
            phi_second_indexes = second_model_phi.index
        else:
            iterate_phi_first = second_model_phi.values
            iterate_phi_second = model_phi.values
            phi_first_indexes = second_model_phi.index
            phi_second_indexes = model_phi.index

        first_map_order = []
        second_map_order = []
        while iterate_phi_second.shape[0] &gt; 0:
            answer_batch = compute_topic_mapping(iterate_phi_first,
                                                 iterate_phi_second,
                                                 metric=self.metric)
            first_map_order += list(phi_first_indexes[answer_batch[0]])
            second_map_order += list(phi_second_indexes[answer_batch[1]])
            iterate_phi_second = np.delete(iterate_phi_second, answer_batch[1], axis=0)
            phi_second_indexes = np.delete(phi_second_indexes, answer_batch[1], axis=0)

        if more_topics_second:
            first_model_order = list(
                model_phi
                .loc[first_map_order]
                .index.values
            )
            second_model_order = list(
                second_model_phi
                .loc[second_map_order]
                .index.values
            )
            return first_model_order, second_model_order

        second_model_order = list(
            second_model_phi
            .loc[first_map_order]
            .index.values
        )
        first_model_order = list(
            model_phi
            .loc[second_map_order]
            .index.values
        )
        return first_model_order, second_model_order
    else:
        raise TypeError(&#39;unknown self.mode value&#39;)</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.topic_mapping.TopicMapViewer.view_from_jupyter"><code class="name flex">
<span>def <span class="ident">view_from_jupyter</span></span>(<span>self, display_output=True, give_html=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>TopicMapViewer method recommended for use
from jupyter notebooks
returns closest pairs of models topics
and visualizes their top tokens</p>
<p>The class provide information about top tokens
of the model topics providing with different methods to score that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>display_output</code></strong></dt>
<dd>if provide output at the end of method run</dd>
<dt><strong><code>give_html</code></strong></dt>
<dd>return html string generated by the method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>out_html</code></dt>
<dd>html string of the output</dd>
</dl>
<h2 id="another-parameters">Another Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd><em>kwargs</em> are optional <code>~.TopTokenViewer</code> properties</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def view_from_jupyter(
        self,
        display_output: bool = True,
        give_html: bool = False,
        **kwargs
):
    &#34;&#34;&#34;
    TopicMapViewer method recommended for use
    from jupyter notebooks
    returns closest pairs of models topics
    and visualizes their top tokens

    The class provide information about top tokens
    of the model topics providing with different methods to score that.

    Parameters
    ----------
    display_output
        if provide output at the end of method run
    give_html
        return html string generated by the method

    Returns
    -------
    out_html
        html string of the output

    Another Parameters
    ------------------
    **kwargs
        *kwargs* are optional `~.TopTokenViewer` properties
    &#34;&#34;&#34;
    from IPython.display import display_html
    from topicnet.cooking_machine.pretty_output import make_notebook_pretty
    if &#39;digits&#39; in kwargs:
        digits = kwargs.pop(&#39;digits&#39;)
    else:
        digits = 5

    make_notebook_pretty()
    first_model_order, second_model_order = self.view()
    token_view = (TopTokensViewer(model=self.model, **kwargs)
                  .view_from_jupyter(
                      topic_names=first_model_order,
                      digits=digits,
                      display_output=False,
                      give_html=True))
    second_token_view = (TopTokensViewer(model=self.second_model, **kwargs)
                         .view_from_jupyter(
                             topic_names=second_model_order,
                             digits=digits,
                             display_output=False,
                             give_html=True))
    model_name = self.model.model_id
    second_model_name = self.second_model.model_id
    out_html = &#39;&lt;table style=display:inline; cellpadding=&#34;5&#34;;&gt;&lt;tbody&gt;{0}&lt;/tbody&gt;&lt;/table&gt;&#39;
    first_element = (f&#39;&lt;tr&gt;&lt;td&gt; First model name: &#39;
                     f&#39;{model_name}&lt;/td&gt;&lt;td&gt; Second model &#39;
                     f&#39;name: {second_model_name}&lt;/td&gt;&lt;/tr&gt;{{0}}&#39;
                     )
    out_html = out_html.format(first_element)
    table_contents = []
    for t1, t2 in zip(token_view, second_token_view):
        table_contents += [f&#39;&lt;tr&gt;&lt;td&gt;{t1}&lt;/td&gt;&lt;td&gt;{t2}&lt;/td&gt;&lt;/tr&gt;&#39;]
    out_html = out_html.format(&#39;&#39;.join(table_contents))
    if display_output:
        display_html(out_html, raw=True)
    if give_html:
        return out_html</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="topicnet.viewers" href="index.html">topicnet.viewers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="topicnet.viewers.topic_mapping.compute_topic_mapping" href="#topicnet.viewers.topic_mapping.compute_topic_mapping">compute_topic_mapping</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="topicnet.viewers.topic_mapping.TopicMapViewer" href="#topicnet.viewers.topic_mapping.TopicMapViewer">TopicMapViewer</a></code></h4>
<ul class="">
<li><code><a title="topicnet.viewers.topic_mapping.TopicMapViewer.view" href="#topicnet.viewers.topic_mapping.TopicMapViewer.view">view</a></code></li>
<li><code><a title="topicnet.viewers.topic_mapping.TopicMapViewer.view_from_jupyter" href="#topicnet.viewers.topic_mapping.TopicMapViewer.view_from_jupyter">view_from_jupyter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>