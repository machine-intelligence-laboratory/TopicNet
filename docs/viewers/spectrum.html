<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>topicnet.viewers.spectrum API documentation</title>
<meta name="description" content="A few ways to obtain &#34;decent&#34; solution to TSP problem
which returns a spectre of topics in our case.
If speed is the essence I recommend to use â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>topicnet.viewers.spectrum</code></h1>
</header>
<section id="section-intro">
<p>A few ways to obtain "decent" solution to TSP problem
which returns a spectre of topics in our case.<br>
If speed is the essence I recommend to use functions providing
good initial solution. Which are, get_nearest_neighbour_init.<br>
If that solution is not good enough use annealing heuristic (get_annealed_spectrum).<br>
Another good but time-heavy option is full check with get_three_opt_path.<br>
Performs well on &lt; 50 topics.<br>
Within a few runs with right temperature selected it can provide a
solution better than the initial.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
A few ways to obtain &#34;decent&#34; solution to TSP problem
which returns a spectre of topics in our case.  
If speed is the essence I recommend to use functions providing
good initial solution. Which are, get_nearest_neighbour_init.  
If that solution is not good enough use annealing heuristic (get_annealed_spectrum).  
Another good but time-heavy option is full check with get_three_opt_path.  
Performs well on &lt; 50 topics.  
Within a few runs with right temperature selected it can provide a
solution better than the initial.
&#34;&#34;&#34;  # noqa: W291
import numpy as np
import warnings
from scipy.spatial import distance
from tqdm import tqdm

from .top_tokens_viewer import TopTokensViewer
from .base_viewer import BaseViewer


def get_nearest_neighbour_init(phi_matrix, metric=&#39;jensenshannon&#39;, start_topic=0):
    &#34;&#34;&#34;
    Given the matrix calculates the initial path by nearest neighbour heuristic.

    Parameters
    ----------
    phi_matrix : np.array of float
        a matrix of N topics x M tokens from the model
    metric : str
        name of a metric to compute distances (Default value = &#39;jensenshannon&#39;)
    start_topic : int
        an index of a topic to start and end the path with (Default value = 0)

    Returns
    -------
    init_path : list of int
        order of initial topic distribution

    &#34;&#34;&#34;
    init_path = [start_topic, ]
    connection_candidates = [int(topic) for topic in np.arange(phi_matrix.shape[0])
                             if topic not in init_path]
    neighbour_vectors = phi_matrix[connection_candidates, :]

    while len(connection_candidates) &gt; 0:
        last_connection = phi_matrix[[init_path[-1]]]
        nearest_index = distance.cdist(last_connection, neighbour_vectors, metric=metric).argmin()
        init_path.append(connection_candidates[nearest_index])
        connection_candidates = [int(topic) for topic in np.arange(phi_matrix.shape[0])
                                 if topic not in init_path]
        neighbour_vectors = np.delete(neighbour_vectors, nearest_index, axis=0)

    init_path.append(start_topic)
    init_path = [int(topic) for topic in init_path]
    return init_path


def generate_all_segments(n):
    &#34;&#34;&#34;
    Generates all segments combinations for 3-opt swap operation.

    Parameters
    ----------
    n : int &gt; 5
        length of path for fixed endpoint

    Yields
    -------
    list of int

    &#34;&#34;&#34;
    for i in range(n-1):
        for j in range(i + 2, n - 1):
            for k in range(j + 2, n - 1):  # + (i &gt; 0)
                yield [i, j, k]


def generate_three_opt_candidates(path, sequence):
    &#34;&#34;&#34;
    Generates all possible tour connections and filters out a trivial one.

    Parameters
    ----------
    path : np.array of float
        square matrix of distances between all topics
    sequence : list of int
        list of indices to perform swap on

    Yields
    ------
    list of int
        possible tour

    &#34;&#34;&#34;
    chunk_start = path[:sequence[0] + 1]
    chunk_one = path[sequence[0] + 1:sequence[1] + 1]
    chunk_two = path[sequence[1] + 1:sequence[2] + 1]
    chunk_end = path[sequence[2] + 1:]

    for change_chunks in [True, False]:
        middle_chunks = [chunk_two, chunk_one] if change_chunks else [chunk_one, chunk_two]

        for reverse_first_chunk in [True, False]:
            if reverse_first_chunk:
                first_chunk = middle_chunks[0][::-1]
            else:
                first_chunk = middle_chunks[0]

            for reverse_second_chunk in [True, False]:

                if reverse_second_chunk:
                    second_chunk = middle_chunks[1][::-1]
                else:
                    second_chunk = middle_chunks[1]

                if change_chunks or reverse_first_chunk or reverse_second_chunk:
                    tour = chunk_start + first_chunk + second_chunk + chunk_end
                    yield tour


def make_three_opt_swap(path, distance_m, sequence, temperature=None):
    &#34;&#34;&#34;
    Performs swap based on the selection candidates,
    allows for non-optimal solution to be accepted
    based on Boltzman distribution.

    Parameters
    ----------
    path : list of int
        current path
    distance_m : np.array of float
        square matrix of distances between all topics
    sequence : list of int
        list of indices to perform swap on
    temperature : float
        &#34;temperature&#34; parameter regulates strictness of
        the new candidate choice (Default value = None)
        if None - works in a regime when only better solutions are chosen  
        This regime is used for 3-opt heuristic

    Returns
    -------
    path : list of int
        best path after the permutation
    val : float
        a value gained after the path permutation

    &#34;&#34;&#34;  # noqa: W291

    cut_connections = sum([[path[ind], path[ind + 1]] for ind in sequence], [])
    baseline = np.sum(distance_m[cut_connections[:-1], cut_connections[1:]])

    # 6 == len(cut_connections) always
    new_connections = list(generate_three_opt_candidates(cut_connections,
                                                         generate_index_candidates(6)))

    candidates = list(generate_three_opt_candidates(path, sequence))
    scores = [np.sum(distance_m[new[:-1], new[1:]]) - baseline for new in new_connections]
    best_score = np.min(scores)

    if best_score &lt; 0.0:
        path = candidates[np.argmin(scores)]
        val = best_score
    else:
        if temperature is None:
            val = 0.0
        else:
            # 1e-8 saves from division by 0
            boltzman = np.exp(- best_score / temperature)
            val = 0.0
            if np.random.rand() &gt; boltzman:
                path = candidates[np.argmin(scores)]
                val = best_score

    return path, val


def get_three_opt_path(path, distance_m, max_iter=20):
    &#34;&#34;&#34;
    Iterative improvement based on 3 opt exchange.

    Parameters
    ----------
    path : list of int
        path to optimize
    distance_m : np.array of float
        square matrix of distances between all topics, 
        attempt at optimizing path from the other end
    max_iter : int
        maximum iteration number (Default value = 20)

    Returns
    -------
    path : list of int
        end optimization of the route

    &#34;&#34;&#34;  # noqa: W291
    count_iter = 0
    while True and count_iter &lt;= max_iter:
        delta = 0

        for segment in generate_all_segments(len(path)):
            path, d = make_three_opt_swap(path, distance_m, segment)
            delta += d
        count_iter += 1
        if count_iter &gt;= max_iter:
            warnings.warn(&#39;Reached maximum iterations&#39;, UserWarning)
        if delta &gt;= 0:
            break

    return path


def generate_index_candidates(n):
    &#34;&#34;&#34;
    Randomly chooses 3 indexes from the path.  
    Does not swap the first or the last point because they fixed.

    Parameters
    ----------
    n : int &gt; 5
        length of the path

    Returns
    -------
    segment: list of int
        sorted list of candidates for 3 opt swap optimization

    &#34;&#34;&#34;  # noqa: W291
    segment = np.zeros(3, dtype=&#39;int&#39;)

    first_interval = np.arange(n - 5)
    segment[0] = np.random.choice(first_interval)

    second_interval = np.arange(segment[0] + 2, n - 3)
    segment[1] = np.random.choice(second_interval)

    third_interval = np.arange(segment[1] + 2, n - 1)
    segment[2] = np.random.choice(third_interval, 1)

    return segment


def get_annealed_spectrum(phi_matrix,
                          t_coeff,
                          start_topic=0,
                          metric=&#39;jensenshannon&#39;,
                          init_path=None,
                          max_iter=1000000,
                          early_stopping=100000,):
    &#34;&#34;&#34;
    Returns annealed spectrum for the topics in the Phi matrix
    with default metrics being Jensen-Shannon.

    Parameters
    ----------
    phi_matrix : np.array of float
        Phi matrix of N topics x M tokens from the model
    t_coeff : float
        coefficient that brings ambiguity to the process,
        bigger coefficient allows to jump from local minima.
    start_topic : int
        index of a topic to start and end the path with (Default value = 0)
    metric : str
        name of a metric to compute distances (Default value = &#39;jensenshannon&#39;)
    init_path : list of int
        initial route, contains all numbers from 0 to N-1,
        starts and ends with the same number from the given range (Default value = None)
    max_iter : int
        number of iterations for annealing (Default value = 1000000)
    early_stopping : int
        number of iterations without improvement before stop (Default value = 100000)

    Returns
    -------
    best_path : list of int
        best path obtained during the run
    best_score : float
        length of the best path during the run

    &#34;&#34;&#34;  # noqa: W291
    distance_m = distance.squareform(distance.pdist(phi_matrix, metric=metric))
    np.fill_diagonal(distance_m, 10 * np.max(distance_m))
    if init_path is None:
        current_path = get_nearest_neighbour_init(phi_matrix,
                                                  metric=metric,
                                                  start_topic=start_topic)
    else:
        current_path = init_path

    if len(current_path) &lt; 6:
        warnings.warn(&#39;The path is too short, returning nearest neighbour solution.&#39;,
                      UserWarning)
        return current_path, np.sum(distance_m[current_path[:-1], current_path[1:]])

    best_score = np.sum(distance_m[current_path[:-1], current_path[1:]])
    best_path = current_path
    running_score = best_score

    no_progress_steps = 0
    for i in tqdm(range(max_iter), total=max_iter, leave=False):
        temperature_iter = t_coeff * (max_iter / (i + 1))
        sequence = generate_index_candidates(len(current_path))
        current_path, score = make_three_opt_swap(current_path,
                                                  distance_m,
                                                  sequence,
                                                  temperature=temperature_iter)
        running_score += score

        if running_score &lt; best_score:
            best_path = current_path
            best_score = running_score
            no_progress_steps = 0
        else:
            no_progress_steps += 1
        if no_progress_steps &gt;= early_stopping:
            break
    return best_path, best_score


class TopicSpectrumViewer(BaseViewer):
    def __init__(
        self,
        model,
        t_coeff=1e5,
        start_topic=0,
        metric=&#39;jensenshannon&#39;,
        init_path=None,
        max_iter=1000000,
        early_stopping=100000,
        verbose=False,
        class_ids=None
    ):
        &#34;&#34;&#34;
        Class providing wrap around for functions
        that allow to view a collection of topics
        in order of their similarity to each other.

        Parameters
        ----------
        model : TopicModel
            topic model from TopicNet library
        t_coeff : float
            coefficient for annealing, value should be chosen
        start_topic : int
            number of model topic to start from
        metric : string or function
            name of the default metric implemented in scipy or function 
            that calculates metric based on the input matrix
        init_path : list of int
            initial tour that could be provided by the user
        max_iter : int
            number of iterations for annealing
        early_stopping : int
            number of iterations without improvement before stop
        verbose : boolean
            if print the resulting length of the tour
        class_ids : list of str
            parameter for model.get_phi method
            contains list of modalities to obtain from the model
            (Default value = None)
        &#34;&#34;&#34;  # noqa: W291
        super().__init__(model=model)
        self.metric = metric
        self.start_topic = start_topic
        self.t_coeff = t_coeff
        self.init_path = init_path
        self.verbose = verbose
        self.early_stopping = early_stopping
        self.max_iter = max_iter
        self.class_ids = class_ids

    def view(self, class_ids=None):
        &#34;&#34;&#34;
        The class method returning ordered spectrum of
        the topics.

        Parameters
        ----------
        class_ids : list of str
            parameter for model.get_phi method
            contains list of modalities to obtain from the model (Default value = None)
        ordered_topics : list of str
            topic names from the model ordered as spectrum

        &#34;&#34;&#34;  # noqa: W291
        # default get_phi returns N x T matrix while we implemented T x N
        if class_ids is None:
            class_ids = self.class_ids
        model_phi = self.model.get_phi(class_ids=class_ids).T
        spectrum, distance = get_annealed_spectrum(model_phi.values,
                                                   self.t_coeff,
                                                   metric=self.metric,
                                                   start_topic=self.start_topic,
                                                   init_path=self.init_path,
                                                   max_iter=self.max_iter,
                                                   early_stopping=self.early_stopping,)
        if self.verbose:
            print(&#39;the resulting path length: &#39;, distance)
        ordered_topics = list(
            model_phi
            .iloc[spectrum]
            .index.values
        )
        return ordered_topics

    def view_from_jupyter(
            self,
            class_ids=None,
            display_output=True,
            give_html=False,
            **kwargs
    ):
        &#34;&#34;&#34;
        TopicSpectrumViewer method recommended for use
        from jupyter notebooks
        returns ordered list of topics minimizing
        path that connects all of them in topic space
        and visualizes their top tokens in given topic order

        Parameters
        ----------
        class_ids : list of int
            class ids for documents in topic needed only for tfidf method
        display_output
            if provide output at the end of method run
        give_html
            return html string generated by the method

        Returns
        -------
        out_html : str
            html string of the output

        Another Parameters
        ------------------
        **kwargs
            *kwargs* are optional `~.TopTokenViewer` properties
        &#34;&#34;&#34;
        from IPython.display import display_html
        if &#39;digits&#39; in kwargs:
            digits = kwargs.pop(&#39;digits&#39;)
        else:
            digits = 5

        spectrum_order = self.view(class_ids=class_ids)
        print(&#39;Viewing topics in the following order:&#39;)
        topic_order = &#39;&amp;#8594;&#39;.join(spectrum_order)
        display_html(topic_order, raw=True)
        out_html = (TopTokensViewer(
            model=self.model,
            class_ids=class_ids,
            **kwargs
        )
                      .view_from_jupyter(
                          topic_names=spectrum_order,
                          digits=digits,
                          display_output=display_output,
                          give_html=give_html)
                     )
        if give_html:
            return &#39;&lt;br /&gt;&#39;.join([topic_order, out_html])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="topicnet.viewers.spectrum.generate_all_segments"><code class="name flex">
<span>def <span class="ident">generate_all_segments</span></span>(<span>n)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all segments combinations for 3-opt swap operation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code> &gt; <code>5</code></dt>
<dd>length of path for fixed endpoint</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_all_segments(n):
    &#34;&#34;&#34;
    Generates all segments combinations for 3-opt swap operation.

    Parameters
    ----------
    n : int &gt; 5
        length of path for fixed endpoint

    Yields
    -------
    list of int

    &#34;&#34;&#34;
    for i in range(n-1):
        for j in range(i + 2, n - 1):
            for k in range(j + 2, n - 1):  # + (i &gt; 0)
                yield [i, j, k]</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.generate_index_candidates"><code class="name flex">
<span>def <span class="ident">generate_index_candidates</span></span>(<span>n)</span>
</code></dt>
<dd>
<section class="desc"><p>Randomly chooses 3 indexes from the path.<br>
Does not swap the first or the last point because they fixed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code> &gt; <code>5</code></dt>
<dd>length of the path</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>segment</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>sorted list of candidates for 3 opt swap optimization</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_index_candidates(n):
    &#34;&#34;&#34;
    Randomly chooses 3 indexes from the path.  
    Does not swap the first or the last point because they fixed.

    Parameters
    ----------
    n : int &gt; 5
        length of the path

    Returns
    -------
    segment: list of int
        sorted list of candidates for 3 opt swap optimization

    &#34;&#34;&#34;  # noqa: W291
    segment = np.zeros(3, dtype=&#39;int&#39;)

    first_interval = np.arange(n - 5)
    segment[0] = np.random.choice(first_interval)

    second_interval = np.arange(segment[0] + 2, n - 3)
    segment[1] = np.random.choice(second_interval)

    third_interval = np.arange(segment[1] + 2, n - 1)
    segment[2] = np.random.choice(third_interval, 1)

    return segment</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.generate_three_opt_candidates"><code class="name flex">
<span>def <span class="ident">generate_three_opt_candidates</span></span>(<span>path, sequence)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates all possible tour connections and filters out a trivial one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>np.array</code> of <code>float</code></dt>
<dd>square matrix of distances between all topics</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>list of indices to perform swap on</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>possible tour</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_three_opt_candidates(path, sequence):
    &#34;&#34;&#34;
    Generates all possible tour connections and filters out a trivial one.

    Parameters
    ----------
    path : np.array of float
        square matrix of distances between all topics
    sequence : list of int
        list of indices to perform swap on

    Yields
    ------
    list of int
        possible tour

    &#34;&#34;&#34;
    chunk_start = path[:sequence[0] + 1]
    chunk_one = path[sequence[0] + 1:sequence[1] + 1]
    chunk_two = path[sequence[1] + 1:sequence[2] + 1]
    chunk_end = path[sequence[2] + 1:]

    for change_chunks in [True, False]:
        middle_chunks = [chunk_two, chunk_one] if change_chunks else [chunk_one, chunk_two]

        for reverse_first_chunk in [True, False]:
            if reverse_first_chunk:
                first_chunk = middle_chunks[0][::-1]
            else:
                first_chunk = middle_chunks[0]

            for reverse_second_chunk in [True, False]:

                if reverse_second_chunk:
                    second_chunk = middle_chunks[1][::-1]
                else:
                    second_chunk = middle_chunks[1]

                if change_chunks or reverse_first_chunk or reverse_second_chunk:
                    tour = chunk_start + first_chunk + second_chunk + chunk_end
                    yield tour</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.get_annealed_spectrum"><code class="name flex">
<span>def <span class="ident">get_annealed_spectrum</span></span>(<span>phi_matrix, t_coeff, start_topic=0, metric='jensenshannon', init_path=None, max_iter=1000000, early_stopping=100000)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns annealed spectrum for the topics in the Phi matrix
with default metrics being Jensen-Shannon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phi_matrix</code></strong> :&ensp;<code>np.array</code> of <code>float</code></dt>
<dd>Phi matrix of N topics x M tokens from the model</dd>
<dt><strong><code>t_coeff</code></strong> :&ensp;<code>float</code></dt>
<dd>coefficient that brings ambiguity to the process,
bigger coefficient allows to jump from local minima.</dd>
<dt><strong><code>start_topic</code></strong> :&ensp;<code>int</code></dt>
<dd>index of a topic to start and end the path with (Default value = 0)</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a metric to compute distances (Default value = 'jensenshannon')</dd>
<dt><strong><code>init_path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>initial route, contains all numbers from 0 to N-1,
starts and ends with the same number from the given range (Default value = None)</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations for annealing (Default value = 1000000)</dd>
<dt><strong><code>early_stopping</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations without improvement before stop (Default value = 100000)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>best_path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>best path obtained during the run</dd>
<dt><strong><code>best_score</code></strong> :&ensp;<code>float</code></dt>
<dd>length of the best path during the run</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_annealed_spectrum(phi_matrix,
                          t_coeff,
                          start_topic=0,
                          metric=&#39;jensenshannon&#39;,
                          init_path=None,
                          max_iter=1000000,
                          early_stopping=100000,):
    &#34;&#34;&#34;
    Returns annealed spectrum for the topics in the Phi matrix
    with default metrics being Jensen-Shannon.

    Parameters
    ----------
    phi_matrix : np.array of float
        Phi matrix of N topics x M tokens from the model
    t_coeff : float
        coefficient that brings ambiguity to the process,
        bigger coefficient allows to jump from local minima.
    start_topic : int
        index of a topic to start and end the path with (Default value = 0)
    metric : str
        name of a metric to compute distances (Default value = &#39;jensenshannon&#39;)
    init_path : list of int
        initial route, contains all numbers from 0 to N-1,
        starts and ends with the same number from the given range (Default value = None)
    max_iter : int
        number of iterations for annealing (Default value = 1000000)
    early_stopping : int
        number of iterations without improvement before stop (Default value = 100000)

    Returns
    -------
    best_path : list of int
        best path obtained during the run
    best_score : float
        length of the best path during the run

    &#34;&#34;&#34;  # noqa: W291
    distance_m = distance.squareform(distance.pdist(phi_matrix, metric=metric))
    np.fill_diagonal(distance_m, 10 * np.max(distance_m))
    if init_path is None:
        current_path = get_nearest_neighbour_init(phi_matrix,
                                                  metric=metric,
                                                  start_topic=start_topic)
    else:
        current_path = init_path

    if len(current_path) &lt; 6:
        warnings.warn(&#39;The path is too short, returning nearest neighbour solution.&#39;,
                      UserWarning)
        return current_path, np.sum(distance_m[current_path[:-1], current_path[1:]])

    best_score = np.sum(distance_m[current_path[:-1], current_path[1:]])
    best_path = current_path
    running_score = best_score

    no_progress_steps = 0
    for i in tqdm(range(max_iter), total=max_iter, leave=False):
        temperature_iter = t_coeff * (max_iter / (i + 1))
        sequence = generate_index_candidates(len(current_path))
        current_path, score = make_three_opt_swap(current_path,
                                                  distance_m,
                                                  sequence,
                                                  temperature=temperature_iter)
        running_score += score

        if running_score &lt; best_score:
            best_path = current_path
            best_score = running_score
            no_progress_steps = 0
        else:
            no_progress_steps += 1
        if no_progress_steps &gt;= early_stopping:
            break
    return best_path, best_score</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.get_nearest_neighbour_init"><code class="name flex">
<span>def <span class="ident">get_nearest_neighbour_init</span></span>(<span>phi_matrix, metric='jensenshannon', start_topic=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Given the matrix calculates the initial path by nearest neighbour heuristic.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phi_matrix</code></strong> :&ensp;<code>np.array</code> of <code>float</code></dt>
<dd>a matrix of N topics x M tokens from the model</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a metric to compute distances (Default value = 'jensenshannon')</dd>
<dt><strong><code>start_topic</code></strong> :&ensp;<code>int</code></dt>
<dd>an index of a topic to start and end the path with (Default value = 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>init_path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>order of initial topic distribution</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_nearest_neighbour_init(phi_matrix, metric=&#39;jensenshannon&#39;, start_topic=0):
    &#34;&#34;&#34;
    Given the matrix calculates the initial path by nearest neighbour heuristic.

    Parameters
    ----------
    phi_matrix : np.array of float
        a matrix of N topics x M tokens from the model
    metric : str
        name of a metric to compute distances (Default value = &#39;jensenshannon&#39;)
    start_topic : int
        an index of a topic to start and end the path with (Default value = 0)

    Returns
    -------
    init_path : list of int
        order of initial topic distribution

    &#34;&#34;&#34;
    init_path = [start_topic, ]
    connection_candidates = [int(topic) for topic in np.arange(phi_matrix.shape[0])
                             if topic not in init_path]
    neighbour_vectors = phi_matrix[connection_candidates, :]

    while len(connection_candidates) &gt; 0:
        last_connection = phi_matrix[[init_path[-1]]]
        nearest_index = distance.cdist(last_connection, neighbour_vectors, metric=metric).argmin()
        init_path.append(connection_candidates[nearest_index])
        connection_candidates = [int(topic) for topic in np.arange(phi_matrix.shape[0])
                                 if topic not in init_path]
        neighbour_vectors = np.delete(neighbour_vectors, nearest_index, axis=0)

    init_path.append(start_topic)
    init_path = [int(topic) for topic in init_path]
    return init_path</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.get_three_opt_path"><code class="name flex">
<span>def <span class="ident">get_three_opt_path</span></span>(<span>path, distance_m, max_iter=20)</span>
</code></dt>
<dd>
<section class="desc"><p>Iterative improvement based on 3 opt exchange.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>path to optimize</dd>
<dt><strong><code>distance_m</code></strong> :&ensp;<code>np.array</code> of <code>float</code></dt>
<dd>square matrix of distances between all topics,
attempt at optimizing path from the other end</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum iteration number (Default value = 20)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>end optimization of the route</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_three_opt_path(path, distance_m, max_iter=20):
    &#34;&#34;&#34;
    Iterative improvement based on 3 opt exchange.

    Parameters
    ----------
    path : list of int
        path to optimize
    distance_m : np.array of float
        square matrix of distances between all topics, 
        attempt at optimizing path from the other end
    max_iter : int
        maximum iteration number (Default value = 20)

    Returns
    -------
    path : list of int
        end optimization of the route

    &#34;&#34;&#34;  # noqa: W291
    count_iter = 0
    while True and count_iter &lt;= max_iter:
        delta = 0

        for segment in generate_all_segments(len(path)):
            path, d = make_three_opt_swap(path, distance_m, segment)
            delta += d
        count_iter += 1
        if count_iter &gt;= max_iter:
            warnings.warn(&#39;Reached maximum iterations&#39;, UserWarning)
        if delta &gt;= 0:
            break

    return path</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.make_three_opt_swap"><code class="name flex">
<span>def <span class="ident">make_three_opt_swap</span></span>(<span>path, distance_m, sequence, temperature=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs swap based on the selection candidates,
allows for non-optimal solution to be accepted
based on Boltzman distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>current path</dd>
<dt><strong><code>distance_m</code></strong> :&ensp;<code>np.array</code> of <code>float</code></dt>
<dd>square matrix of distances between all topics</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>list of indices to perform swap on</dd>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code></dt>
<dd>"temperature" parameter regulates strictness of
the new candidate choice (Default value = None)
if None - works in a regime when only better solutions are chosen<br>
This regime is used for 3-opt heuristic</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>best path after the permutation</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>float</code></dt>
<dd>a value gained after the path permutation</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_three_opt_swap(path, distance_m, sequence, temperature=None):
    &#34;&#34;&#34;
    Performs swap based on the selection candidates,
    allows for non-optimal solution to be accepted
    based on Boltzman distribution.

    Parameters
    ----------
    path : list of int
        current path
    distance_m : np.array of float
        square matrix of distances between all topics
    sequence : list of int
        list of indices to perform swap on
    temperature : float
        &#34;temperature&#34; parameter regulates strictness of
        the new candidate choice (Default value = None)
        if None - works in a regime when only better solutions are chosen  
        This regime is used for 3-opt heuristic

    Returns
    -------
    path : list of int
        best path after the permutation
    val : float
        a value gained after the path permutation

    &#34;&#34;&#34;  # noqa: W291

    cut_connections = sum([[path[ind], path[ind + 1]] for ind in sequence], [])
    baseline = np.sum(distance_m[cut_connections[:-1], cut_connections[1:]])

    # 6 == len(cut_connections) always
    new_connections = list(generate_three_opt_candidates(cut_connections,
                                                         generate_index_candidates(6)))

    candidates = list(generate_three_opt_candidates(path, sequence))
    scores = [np.sum(distance_m[new[:-1], new[1:]]) - baseline for new in new_connections]
    best_score = np.min(scores)

    if best_score &lt; 0.0:
        path = candidates[np.argmin(scores)]
        val = best_score
    else:
        if temperature is None:
            val = 0.0
        else:
            # 1e-8 saves from division by 0
            boltzman = np.exp(- best_score / temperature)
            val = 0.0
            if np.random.rand() &gt; boltzman:
                path = candidates[np.argmin(scores)]
                val = best_score

    return path, val</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="topicnet.viewers.spectrum.TopicSpectrumViewer"><code class="flex name class">
<span>class <span class="ident">TopicSpectrumViewer</span></span>
<span>(</span><span>model, t_coeff=100000.0, start_topic=0, metric='jensenshannon', init_path=None, max_iter=1000000, early_stopping=100000, verbose=False, class_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Class providing wrap around for functions
that allow to view a collection of topics
in order of their similarity to each other.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>TopicModel</code></dt>
<dd>topic model from TopicNet library</dd>
<dt><strong><code>t_coeff</code></strong> :&ensp;<code>float</code></dt>
<dd>coefficient for annealing, value should be chosen</dd>
<dt><strong><code>start_topic</code></strong> :&ensp;<code>int</code></dt>
<dd>number of model topic to start from</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>string</code> or <code>function</code></dt>
<dd>name of the default metric implemented in scipy or function
that calculates metric based on the input matrix</dd>
<dt><strong><code>init_path</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>initial tour that could be provided by the user</dd>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations for annealing</dd>
<dt><strong><code>early_stopping</code></strong> :&ensp;<code>int</code></dt>
<dd>number of iterations without improvement before stop</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if print the resulting length of the tour</dd>
<dt><strong><code>class_ids</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>parameter for model.get_phi method
contains list of modalities to obtain from the model
(Default value = None)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TopicSpectrumViewer(BaseViewer):
    def __init__(
        self,
        model,
        t_coeff=1e5,
        start_topic=0,
        metric=&#39;jensenshannon&#39;,
        init_path=None,
        max_iter=1000000,
        early_stopping=100000,
        verbose=False,
        class_ids=None
    ):
        &#34;&#34;&#34;
        Class providing wrap around for functions
        that allow to view a collection of topics
        in order of their similarity to each other.

        Parameters
        ----------
        model : TopicModel
            topic model from TopicNet library
        t_coeff : float
            coefficient for annealing, value should be chosen
        start_topic : int
            number of model topic to start from
        metric : string or function
            name of the default metric implemented in scipy or function 
            that calculates metric based on the input matrix
        init_path : list of int
            initial tour that could be provided by the user
        max_iter : int
            number of iterations for annealing
        early_stopping : int
            number of iterations without improvement before stop
        verbose : boolean
            if print the resulting length of the tour
        class_ids : list of str
            parameter for model.get_phi method
            contains list of modalities to obtain from the model
            (Default value = None)
        &#34;&#34;&#34;  # noqa: W291
        super().__init__(model=model)
        self.metric = metric
        self.start_topic = start_topic
        self.t_coeff = t_coeff
        self.init_path = init_path
        self.verbose = verbose
        self.early_stopping = early_stopping
        self.max_iter = max_iter
        self.class_ids = class_ids

    def view(self, class_ids=None):
        &#34;&#34;&#34;
        The class method returning ordered spectrum of
        the topics.

        Parameters
        ----------
        class_ids : list of str
            parameter for model.get_phi method
            contains list of modalities to obtain from the model (Default value = None)
        ordered_topics : list of str
            topic names from the model ordered as spectrum

        &#34;&#34;&#34;  # noqa: W291
        # default get_phi returns N x T matrix while we implemented T x N
        if class_ids is None:
            class_ids = self.class_ids
        model_phi = self.model.get_phi(class_ids=class_ids).T
        spectrum, distance = get_annealed_spectrum(model_phi.values,
                                                   self.t_coeff,
                                                   metric=self.metric,
                                                   start_topic=self.start_topic,
                                                   init_path=self.init_path,
                                                   max_iter=self.max_iter,
                                                   early_stopping=self.early_stopping,)
        if self.verbose:
            print(&#39;the resulting path length: &#39;, distance)
        ordered_topics = list(
            model_phi
            .iloc[spectrum]
            .index.values
        )
        return ordered_topics

    def view_from_jupyter(
            self,
            class_ids=None,
            display_output=True,
            give_html=False,
            **kwargs
    ):
        &#34;&#34;&#34;
        TopicSpectrumViewer method recommended for use
        from jupyter notebooks
        returns ordered list of topics minimizing
        path that connects all of them in topic space
        and visualizes their top tokens in given topic order

        Parameters
        ----------
        class_ids : list of int
            class ids for documents in topic needed only for tfidf method
        display_output
            if provide output at the end of method run
        give_html
            return html string generated by the method

        Returns
        -------
        out_html : str
            html string of the output

        Another Parameters
        ------------------
        **kwargs
            *kwargs* are optional `~.TopTokenViewer` properties
        &#34;&#34;&#34;
        from IPython.display import display_html
        if &#39;digits&#39; in kwargs:
            digits = kwargs.pop(&#39;digits&#39;)
        else:
            digits = 5

        spectrum_order = self.view(class_ids=class_ids)
        print(&#39;Viewing topics in the following order:&#39;)
        topic_order = &#39;&amp;#8594;&#39;.join(spectrum_order)
        display_html(topic_order, raw=True)
        out_html = (TopTokensViewer(
            model=self.model,
            class_ids=class_ids,
            **kwargs
        )
                      .view_from_jupyter(
                          topic_names=spectrum_order,
                          digits=digits,
                          display_output=display_output,
                          give_html=give_html)
                     )
        if give_html:
            return &#39;&lt;br /&gt;&#39;.join([topic_order, out_html])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="topicnet.viewers.base_viewer.BaseViewer" href="base_viewer.html#topicnet.viewers.base_viewer.BaseViewer">BaseViewer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="topicnet.viewers.spectrum.TopicSpectrumViewer.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, class_ids=None)</span>
</code></dt>
<dd>
<section class="desc"><p>The class method returning ordered spectrum of
the topics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>class_ids</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>parameter for model.get_phi method
contains list of modalities to obtain from the model (Default value = None)</dd>
<dt><strong><code>ordered_topics</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>topic names from the model ordered as spectrum</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def view(self, class_ids=None):
    &#34;&#34;&#34;
    The class method returning ordered spectrum of
    the topics.

    Parameters
    ----------
    class_ids : list of str
        parameter for model.get_phi method
        contains list of modalities to obtain from the model (Default value = None)
    ordered_topics : list of str
        topic names from the model ordered as spectrum

    &#34;&#34;&#34;  # noqa: W291
    # default get_phi returns N x T matrix while we implemented T x N
    if class_ids is None:
        class_ids = self.class_ids
    model_phi = self.model.get_phi(class_ids=class_ids).T
    spectrum, distance = get_annealed_spectrum(model_phi.values,
                                               self.t_coeff,
                                               metric=self.metric,
                                               start_topic=self.start_topic,
                                               init_path=self.init_path,
                                               max_iter=self.max_iter,
                                               early_stopping=self.early_stopping,)
    if self.verbose:
        print(&#39;the resulting path length: &#39;, distance)
    ordered_topics = list(
        model_phi
        .iloc[spectrum]
        .index.values
    )
    return ordered_topics</code></pre>
</details>
</dd>
<dt id="topicnet.viewers.spectrum.TopicSpectrumViewer.view_from_jupyter"><code class="name flex">
<span>def <span class="ident">view_from_jupyter</span></span>(<span>self, class_ids=None, display_output=True, give_html=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>TopicSpectrumViewer method recommended for use
from jupyter notebooks
returns ordered list of topics minimizing
path that connects all of them in topic space
and visualizes their top tokens in given topic order</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>class_ids</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>class ids for documents in topic needed only for tfidf method</dd>
<dt><strong><code>display_output</code></strong></dt>
<dd>if provide output at the end of method run</dd>
<dt><strong><code>give_html</code></strong></dt>
<dd>return html string generated by the method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out_html</code></strong> :&ensp;<code>str</code></dt>
<dd>html string of the output</dd>
</dl>
<h2 id="another-parameters">Another Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd><em>kwargs</em> are optional <code>~.TopTokenViewer</code> properties</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def view_from_jupyter(
        self,
        class_ids=None,
        display_output=True,
        give_html=False,
        **kwargs
):
    &#34;&#34;&#34;
    TopicSpectrumViewer method recommended for use
    from jupyter notebooks
    returns ordered list of topics minimizing
    path that connects all of them in topic space
    and visualizes their top tokens in given topic order

    Parameters
    ----------
    class_ids : list of int
        class ids for documents in topic needed only for tfidf method
    display_output
        if provide output at the end of method run
    give_html
        return html string generated by the method

    Returns
    -------
    out_html : str
        html string of the output

    Another Parameters
    ------------------
    **kwargs
        *kwargs* are optional `~.TopTokenViewer` properties
    &#34;&#34;&#34;
    from IPython.display import display_html
    if &#39;digits&#39; in kwargs:
        digits = kwargs.pop(&#39;digits&#39;)
    else:
        digits = 5

    spectrum_order = self.view(class_ids=class_ids)
    print(&#39;Viewing topics in the following order:&#39;)
    topic_order = &#39;&amp;#8594;&#39;.join(spectrum_order)
    display_html(topic_order, raw=True)
    out_html = (TopTokensViewer(
        model=self.model,
        class_ids=class_ids,
        **kwargs
    )
                  .view_from_jupyter(
                      topic_names=spectrum_order,
                      digits=digits,
                      display_output=display_output,
                      give_html=give_html)
                 )
    if give_html:
        return &#39;&lt;br /&gt;&#39;.join([topic_order, out_html])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="topicnet.viewers" href="index.html">topicnet.viewers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="topicnet.viewers.spectrum.generate_all_segments" href="#topicnet.viewers.spectrum.generate_all_segments">generate_all_segments</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.generate_index_candidates" href="#topicnet.viewers.spectrum.generate_index_candidates">generate_index_candidates</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.generate_three_opt_candidates" href="#topicnet.viewers.spectrum.generate_three_opt_candidates">generate_three_opt_candidates</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.get_annealed_spectrum" href="#topicnet.viewers.spectrum.get_annealed_spectrum">get_annealed_spectrum</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.get_nearest_neighbour_init" href="#topicnet.viewers.spectrum.get_nearest_neighbour_init">get_nearest_neighbour_init</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.get_three_opt_path" href="#topicnet.viewers.spectrum.get_three_opt_path">get_three_opt_path</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.make_three_opt_swap" href="#topicnet.viewers.spectrum.make_three_opt_swap">make_three_opt_swap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="topicnet.viewers.spectrum.TopicSpectrumViewer" href="#topicnet.viewers.spectrum.TopicSpectrumViewer">TopicSpectrumViewer</a></code></h4>
<ul class="">
<li><code><a title="topicnet.viewers.spectrum.TopicSpectrumViewer.view" href="#topicnet.viewers.spectrum.TopicSpectrumViewer.view">view</a></code></li>
<li><code><a title="topicnet.viewers.spectrum.TopicSpectrumViewer.view_from_jupyter" href="#topicnet.viewers.spectrum.TopicSpectrumViewer.view_from_jupyter">view_from_jupyter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>